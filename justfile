set shell := ["bash", "-cu"]

lint:
  @command -v shellcheck >/dev/null 2>&1 || { echo 'shellcheck not installed'; exit 1; }
  shellcheck lib/*.sh install/*.sh

test:
  @command -v bats >/dev/null 2>&1 || { echo 'bats not installed'; exit 1; }
  bats tests

build:
  #!/usr/bin/env bash
  set -euxo pipefail

  header() {
    /bin/cat <<'HEADER'
  #!/usr/bin/env bash
  # shellcheck shell=bash
  #
  # Auto-generated by `just build`. Do not edit directly.
  # --- Start of install-lib ---
  HEADER
  }
  
  footer() {
    /bin/cat <<'FOOTER' >>"$DIST"
  # --- End of install-lib ---
  #
  # vim: set ft=bash:
  FOOTER
  }

  LINE_SEP=$'\n'

  ROOT="$(pwd)"
  DIST="$ROOT/dist/install-lib.sh"
  TMP_DIST_MIN=$(mktemp "${TMPDIR:-/tmp}/install-lib.XXXXXX")
  DIST_MIN="$ROOT/dist/install-lib.min.sh"
  MODULES=(
    lib/color.sh
    lib/install-lib.sh
    lib/logging.sh
    lib/ui.sh
    lib/os.sh
    lib/packages.sh
    lib/run.sh
  )

  mkdir -p "$(dirname "$DIST")"

  header >"$DIST"
  for module in "${MODULES[@]}"; do
    {
      echo ""
      echo "# --- ${module} ---"
      /bin/cat "$ROOT/$module" | \
        grep -Ev '^\s*#\s*(shellcheck\s*shell=|!/usr/bin/env\s*bash|vim:\s*set\s*ft=bash:)' | \
        sed '/^[[:space:]]*$/d'
    } >>"$DIST"
  done
  footer >>"$DIST"

  chmod +x "$DIST"
  printf 'Generated %s\n' "$DIST"
 
  /bin/cat "$DIST" >"$TMP_DIST_MIN"
  just minify "$TMP_DIST_MIN" >"$DIST_MIN"

  chmod +x "$DIST_MIN"
  printf 'Generated %s (minified)\n' "$DIST_MIN"

  rm -f "$TMP_DIST_MIN"

minify file:
  #!/usr/bin/env bash
  awk 'NR==1 {print; next}
       /^[[:space:]]*#/ {next}
       /^[[:space:]]*$/ {next}
       { sub(/^[[:space:]]+/, ""); print }' "{{ file }}"

minifier in out:
  #!/usr/bin/env bash
  # License: The MIT License (MIT)
  # Author Zuzzuc https://github.com/Zuzzuc/
  set -euo pipefail
  # Assign variables 
  # Default vars
  self="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

  #Functions
  exitw(){
    # Exit and print exit code.
    # Usage is $1, where $1 is the error code.
    echo "Error code: $1. Exiting"
    exit $1
  }

  sanitizeFilePath(){
    # This function will remove \ and space at the end of a filepath to make it parse well into other, quoted, functions/commands
    # Usage $1, where $1 is a file path.
    echo -n "$(echo "$(echo "$1" | sed 's%\\%%g')" |sed -e 's%[[:space:]]*$%%')"
  }

  readLine(){
    # This function will read line $1. Output to stdout
    # Usage is $1, where $1 is the line to read.
    sed "$1q;d" "$file"
  }

  processData() {
    # This function will format any input line to be able to fit in a one liner. 
    # Usage is $1, where $1 is the data.
    # Remove trailing spaces.
    data="${1//[[:space:]]/}"
    
    ic=0
    modified=0
      
    # Remove comments
    # Temporary fix, will only remove full line comments...
      
    # The following line will check if the line contains '#'
    if [[ "${data}" = *'#'* ]]; then
    
      # Remove any empty characters so comparison will be easier.
      noSpaces="${data## }"
      noTabs="${noSpaces##\t}"
      noVt="${noTabs##\v}"
      noR="${noVt##\r}"
      tmpString="${noR##\n}"
      unset noSpaces noTabs noVt noR
      if [[ "${tmpString:0:1}" == "#" ]];then
        # $data is a full line comment. We'll remove it fully.
        data=""
        ic=1
        modified=1
      fi
    fi
    
    # We should not run this if data is a full line comment, as it will corrupt the script.
    if ((ic == 0)); then
      # Look for exceptions
      if [[ "${data: -2}" == "do" || \
        "${data: -4}" == "then" || \
        "${data: -4}" == "else" || \
        "${data: -4}" == "elif" || \
        "${data: -1}" == "{" ]]; then
        # Add a space
        data="$data "  
        modified=1
      fi
      if [[ "${data: -1}" =~ .*}$ ]]; then
        data="${data//\}/ \};}"
        modified=1
      fi
      if [[ "${data: -1}" == ";" ]] && ((modified==0)); then
        # Add ';' to end of line. 
        data="$data;"
      fi
      if [[ "${data:0:1}" == ";" ]]; then
        data="${data:1}"
      fi
    fi
      
    # Return $data
    echo -n "$data"
  }

  outputFile="$(sanitizeFilePath "{{ out }}")"
  file="$(sanitizeFilePath "{{ in }}")"

  if [[ ! -f "$file" ]]; then
    echo "The file you supplied, '$file', can not be found or is not a file."
    exitw 3
  fi
  
  # Minify
  FirstLine="$(readLine 1)"
  body=""
  line=2
  linesInFile=$(wc -l < "$file")

  while ((line - 1 <= linesInFile)); do
    body+="$(processData "$(readLine $line)")"
    line=$((line+1))
  done
  
  fullfile="$(echo "$FirstLine"; echo "$body")"
  if [[ "${fullfile: -1}" == ";" ]];then
    fullfile="${fullfile::-1}"
  fi
  echo -n "$fullfile" > "$outputFile"

  exit

# vim: set ft=just:
